# 객체지향 프로그래밍

> 프로그래밍에 필요한 데이터를 추상화하여 객체로 만들고, 여러 객체들이 상호작용을 하며 시스템을 구성하는 패러다임

## 특징

### 추상화
데이터에서 필요한 속성이나 행위를 찾아서 추출하는 것을 의미한다.

### 캡슐화
정보 은닉을 통해 객체간의 결합도를 낮추고, 응집도를 높여 변경이 생겨도, 다른 코드에 미치는 영향을 최소하는 것이다.


정보 은닉이란, 값을 private 변수에 선언해서 외부로부터 해당 값을 노출하지 않는 것을 의미한다.

```Kotlin
// 정보 은닉 예
class Capsule {
  private age: Int = 0
}

fun main(){
  val capsule : Capsule = Capsule()
  
  // 접근 불가, 에러 발생
  print(capsule.age)
}
```

결합도란, 어떠한 기능을 수행할때 얼만큼 다른 클래스나 모듈에 의존적인 정도를 나타낸다.

### 상속
여러개의 객체들의 공통된 속성과 행위를 일반화 하는것. 상속은 캡슐화의 일종이며, 자식 클래스에게 부모 클래스의 정보를 은닉한다.

> 상속은 재사용성의 관점이 아닌, 확장을 할때 사용하는 것이 좋다.

### 다형성
서로 다른 클래스의 객체가 같은 메시지를 받았을 때, 각자의 방식대로 처리는 하는 것. 상속 관계에 있는 두 클래스에서 자식 클래스가 부모 클래스의 메소드를 **오버라이드(override)** 하는 것을 의미한ㄷ.

---
## 객체지향 설계 원칙

### 1. SRP(Single Responsibility) - 단일 책임의 원칙
클래스는 하나의 책임만 가지고 있어야하며, 클래스를 변경하는 이유는 오직 하나이여야한다.

### 2. OCP(Open-Closed) - 개방-폐쇄의 원칙
확장에는 열려 있되, 변경에는 닫혀 있어야한다. 기능을 변경하거나, 확장할 수 있으면서 그 기능을 사용하는 코드는 수정되지 않아야한다.

### 3. LSP(Liskov Subsitution) - 리스코프 치환의 원칙
상위 타입의 객체를 사용하는 곳에서 상위 객체를 하위 객체로 변경해도, 기능에 문제가 있으면 안됀다. 
상속 관계가 아닌 객체들을 상속 관계로 만들면 이 원칙에 위배된다.

### 4. ISP(Interface Segregation) - 인터페이스 분리 원칙
인터페이스는 그 인터페이스를 사용하는 클라이언트 기준으로 분리해야한다. 
각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않게 해야한다.

### 5. DIP(Dependecy Inversion) - 의존 역전 원칙
고수준의 모듈은 저수준의 모듈의 구현에 의존해서는 안됀다.
저수분의 모듈이 고수준 모듈에 정의한 추상 타입에 의존해야한다. 즉, 저수준 모듈이 변경되어도 고수준 모듈은 변경할 필요가 없다.
